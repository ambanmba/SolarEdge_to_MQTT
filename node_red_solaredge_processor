// Paste this code to Node red function node.

function formatNumber(number) {
    return Number(number.toFixed(1));
}

// Process all SolarEdge inverter and meter data
if (!msg.payload || !msg.payload.meters || !msg.payload.meters.Meter1) {
    node.status({
        fill: "red",
        shape: "ring",
        text: "No valid data"
    });
    msg.payload.processed = {
        connection_status: "disconnected",
        timestamp: msg.payload.monitoring ? msg.payload.monitoring.last_successful_read : null,
        connection_attempts: msg.payload.monitoring ? msg.payload.monitoring.connection_attempts : 0,
        consecutive_failures: msg.payload.monitoring ? msg.payload.monitoring.consecutive_failures : 0
    };
    return msg;
}

try {
    const meter = msg.payload.meters.Meter1;
    const inverter = msg.payload;

    // Calculate all scaling factors
    const scales = {
        current: Math.pow(10, meter.current_scale),
        voltage: Math.pow(10, meter.voltage_scale),
        power: Math.pow(10, meter.power_scale),
        powerApparent: Math.pow(10, meter.power_apparent_scale),
        powerReactive: Math.pow(10, meter.power_reactive_scale),
        powerFactor: Math.pow(10, meter.power_factor_scale),
        energyActive: Math.pow(10, meter.energy_active_scale),
        frequency: Math.pow(10, meter.frequency_scale),
        dc: {
            current: Math.pow(10, inverter.current_dc_scale),
            voltage: Math.pow(10, inverter.voltage_dc_scale),
            power: Math.pow(10, inverter.power_dc_scale)
        },
        temperature: Math.pow(10, inverter.temperature_scale)
    };

    // Calculate inverter values
    const solar = {
        total_power: formatNumber(inverter.power_ac),
        power_per_phase: formatNumber(inverter.power_ac / 3),
        power_factor: formatNumber(inverter.power_factor * scales.powerFactor),
        apparent_power: formatNumber(inverter.power_apparent),
        reactive_power: formatNumber(inverter.power_reactive * scales.powerReactive),
        dc: {
            current: formatNumber(inverter.current_dc * scales.dc.current),
            voltage: formatNumber(inverter.voltage_dc * scales.dc.voltage),
            power: formatNumber(inverter.power_dc)
        },
        efficiency: formatNumber((inverter.power_ac / inverter.power_dc) * 100),
        temperature: formatNumber(inverter.temperature * scales.temperature)
    };

    // Process meter currents and voltages
    const grid = {
        currents: {
            total: formatNumber(meter.current * scales.current),
            l1: formatNumber(meter.l1_current * scales.current),
            l2: formatNumber(meter.l2_current * scales.current),
            l3: formatNumber(meter.l3_current * scales.current)
        },
        voltages: {
            l1n: formatNumber(meter.l1n_voltage * scales.voltage),
            l2n: formatNumber(meter.l2n_voltage * scales.voltage),
            l3n: formatNumber(meter.l3n_voltage * scales.voltage)
        },
        power: {
            total: formatNumber(meter.power),
            l1: formatNumber(meter.l1_power),
            l2: formatNumber(meter.l2_power),
            l3: formatNumber(meter.l3_power)
        },
        apparent_power: {
            total: formatNumber(meter.power_apparent),
            l1: formatNumber(meter.l1_power_apparent),
            l2: formatNumber(meter.l2_power_apparent),
            l3: formatNumber(meter.l3_power_apparent)
        },
        reactive_power: {
            total: formatNumber(meter.power_reactive * scales.powerReactive),
            l1: formatNumber(meter.l1_power_reactive * scales.powerReactive),
            l2: formatNumber(meter.l2_power_reactive * scales.powerReactive),
            l3: formatNumber(meter.l3_power_reactive * scales.powerReactive)
        },
        power_factor: {
            total: formatNumber(meter.power_factor * scales.powerFactor),
            l1: formatNumber(meter.l1_power_factor * scales.powerFactor),
            l2: formatNumber(meter.l2_power_factor * scales.powerFactor),
            l3: formatNumber(meter.l3_power_factor * scales.powerFactor)
        },
        energy: {
            export: {
                total: formatNumber(meter.export_energy_active * scales.energyActive),
                l1: formatNumber(meter.l1_export_energy_active * scales.energyActive),
                l2: formatNumber(meter.l2_export_energy_active * scales.energyActive),
                l3: formatNumber(meter.l3_export_energy_active * scales.energyActive)
            },
            import: {
                total: formatNumber(meter.import_energy_active * scales.energyActive),
                l1: formatNumber(meter.l1_import_energy_active * scales.energyActive),
                l2: formatNumber(meter.l2_import_energy_active * scales.energyActive),
                l3: formatNumber(meter.l3_import_energy_active * scales.energyActive)
            }
        }
    };

    // Calculate house consumption
    const consumption = {
        total: formatNumber(solar.total_power - grid.power.total),
        l1: formatNumber(solar.power_per_phase - grid.power.l1),
        l2: formatNumber(solar.power_per_phase - grid.power.l2),
        l3: formatNumber(solar.power_per_phase - grid.power.l3)
    };

    // Calculate percentages for visualization
    const percentages = {
        solar_used: formatNumber((consumption.total / solar.total_power) * 100),
        solar_exported: formatNumber((grid.power.total / solar.total_power) * 100)
    };

    // Set node status with key metrics
    const statusText = `Load:${consumption.total}kW Solar:${solar.total_power}kW Export:${grid.power.total}kW`;
    node.status({
        fill: "green",
        shape: consumption.total > solar.total_power ? "ring" : "dot",
        text: statusText
    });

    // Create the processed output
    msg.payload.processed = {
        connection_status: "connected",
        timestamp: inverter.monitoring.last_successful_read,
        solar: solar,
        grid: grid,
        consumption: consumption,
        percentages: percentages,
        system_status: {
            inverter_status: inverter.status,
            temperature: solar.temperature,
            frequency: formatNumber(meter.frequency * scales.frequency)
        }
    };

} catch (error) {
    node.status({
        fill: "red",
        shape: "ring",
        text: "Error: " + error.message
    });
    node.error("Processing error: " + error.message, msg);
}

return msg;
